

[TOC]

### 一、ARP协议介绍

**1、协议介绍**

​	ARP协议的全程是address resolution protocol（地址解析协议），就是把ip地址转换为主机mac地址，为什么要做这样一件事呢？

​	我们使用的TCP/IP是分层协议，其中IP协议位于第二层，属于网络层协议，同时它使用IP地址来表示源主机和目的主机。但其实IP层不是真正负责数据传输的，ip地址本身也是一个逻辑地址，如果单单只有ip地址，是传输不了任何数据的。

​	真正负责网络数据传输的是最下面一层，网络链路层。大多数情况下，链路层的协议是以太网。以太网负责把多个机器连接到一起，组成局域网，并且局域网内每台主机通过唯一的主机mac地址进行区分。所以，数据在链路层传输的时候，需要把目的ip地址转化为目的的mac地址才能进行数据传输。

​	每个主机MAC地址都用6个字节，每个字节用：进行分隔开，例如我的主机地址是：	34:DE:1A:C5:B0:7F

**2、ARP缓存**

​	如果每次主机通讯都要发送ARP协议去查询MAC地址无疑是十分低效率的，所以操作系统会有一个ARP缓存的东西，就是把之前的ARP查询记录保存下来，那么下次如果还是发送数据给之前发送过的ip地址，就可以直接找到对应的MAC地址。这样能大大提高效率。

### 二、ARP首部

​	ARP报文格式如下图所示，非常简单，首部共20个字节。对于IP地址转换为MAC地址来说，ARP报文长度是28个字节。

![](./picture/10.jpg)

- `Hardware Type`：传输 ARP 报文的物理网络类型，最常见的是以太网类型，对应的值是 1。这个字段的长度是 2 字节
- `Protocol Type`：网络报文类型，字段长度是 2 字节。最常用的是 IPv4 报文，对应的值是 2048（十六进制为 0x0800，这和以太网帧中帧类型字段使用的 IP 报文类型相同，这是有意设计的）
- `Hardware Address Length`：物理地址长度，字段长度是 1 比特。ARP 协议报文中物理地址（MAC 地址）有多少比特，对于大部分网络来说，这个值是 6（因为 MAC 地址是 6 个字节，48 比特长）
- `Protocol Address Length`：网络地址长度，字段长度是 1 比特。表示 ARP 协议报文中网络地址（IP 地址）有多少比特，对于大部分网络来说，这个值是 4（因为 IPv4 地址是 4 个字节，32 比特）
- `Opcode`：ARP 报文的类型，接下来我们会看到几种不同的 ARP 报文。这个字段占用 2 个比特，**值为 1 代表 ARP 请求报文，值为 2 代表 ARP 应答报文，3 代表 RARP 请求报文，4 代表 RARP 应答报文**
- `Sender Hardware Address`：当前 ARP 报文的发送方的物理地址（MAC 地址）
- `Send Protocol Address`：当前 ARP 报文发送发的网络地址（IPv4 地址）
- `Target Hardware Address`：当前 ARP 报文接收方的物理地址（MAC 地址），如果是 ARP 情况请，这个字段为空（因为发送方就是不知道对方的 MAC 地址从会使用 ARP 来解析）
- `Target Protocol Address`：当前 ARP 报文接收方的网络地址（IPv4 地址）

### 三、ARP工作流程

**1、两台主机在同一网段**

**第一步：**机器A想和同一个以太网络的机器B通信，A会在自己的ARP表中查找B的MAC地址，如果能找到就直接发送以太网帧；如果没有找到的话，就跳到第二步

**第二步：**机器A发送ARP请求报文去查询机器B的MAC地址，这是一个以太网广播报文，因此交换机会广播到网络中的所有机器。

**第三步：**各个主机收到ARP请求报文，如果发现报文中询问的ip地址与自己不同，则直接丢弃；如果机器人B发现ARP报文中询问的IP地址是自己的地址，那么就生成一个ARP应答报文，把自己的MAC地址填写到报文中，发给主机A。这个报文是单播报文，不会发给其他主机，同时机器B也会把A的ARP记录缓存起来。

**第四步：**机器A收到B发送过来的ARP应答，读取报文B中的MAC地址，使用这个地址和B进行后续通信，同时把它缓存在系统中。

**2、两台主机不在同一网段**

​	当主机A和主机B不在同一网段时，主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B；如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。

### 四、ARP请求报文和应答报文

**1、ARP 请求报文**

首先是机器 A 发送的 ARP 请求，详细的报文内容如下：

![](./picture/11.jpg)

报文列表的 `Info` 字段，对应的内容是：

> Who has 172.16.13.18? Tell 172.16.13.16

这是 wireshark 帮我们解析 ARP 报文，并用英语表达出来。这句话生动地概括了 ARP 请求的意思：**谁知道 172.16.13.18 的物理地址？告诉 172.16.13.16。**

这个以太网帧的源地址是 `50:7b:9d:ca:08:f0`，也就是机器 A 的 MAC 地址；目的地址是 `ff:ff:ff:ff:ff:ff`，这是一个以太网广播地址，**交换机**会把报文发送给网络中所有的主机。

以太网帧类型（Type）字段的值是 `0x0806`，表示该数据帧是个 ARP 请求或者应答。

帧的长度是 42，其中包括 14 字节以太网帧头部，以及 28 字节 ARP 请求数据。

以太网帧内部是 ARP 请求的具体内容，`Opcode` 为 1，表示这是 ARP 请求，发送端（也就是机器 A）的 IP 地址是 `172.16.13.16`，目的端（也就是机器 B）的 IP 地址是 `172.16.13.18`。发送端的 MAC 地址是填写的，而目的端 MAC 地址为空（全部为 0）。

**2、ARP 应答报文**

第二个报文是 ARP 应答，详细报文内容如下图：
![](./picture/12.jpg)

这个报文的 `info` 字段的信息是:

> 172.16.13.18 is at 50:7b:9d:e0:8b:a8

这也概括了 ARP 应答的意思：`172.16.13.18` 的 MAC 地址是 `50:7b:9d:e0:8b:a8`。

和上个报文不同，这是一个单播报文，直接发送到机器 A，帧的目的 MAC 地址是 `50:7b:9d:ca:08:f0`。因为机器 B 能够从接收到的 ARP 请求报文中获取机器 A 的 IP 地址和 MAC 地址，可以直接发送单播。

`Opcode` 字段的值为 2，表示这是个 ARP 应答报文，而且 ARP 报文中四个地址都填上了对应的值（因为此时机器已经知道通信双方的所有地址）。

另外一点需要注意的是，这个以太网帧的长度是 60 字节，因为它的以太网帧后面加了 18 字节的 padding（填充字符）。这是以太网帧的最小长度值，那为什么 ARP 请求报文的长度可以低于 60 呢？这和 wireshark 抓包的原理有关，wireshark 捕获的包并不是真正发送到线路上的帧，而是发送给网卡驱动的数据。因此，如果从机器 B 上抓包，会发现机器 B 接收到的这个 ARP 请求长度也是 60 字节。

通过两个报文的时间可以发现，ARP 地址解析的时间在 0.2ms 左右，说明这个网络并不是非常繁忙，速度还是挺快的。

**3、ARP cache validation 报文**

后两个 ARP 报文也是一对：请求和应答，它们是从机器 B 发来查询机器 A MAC 地址的。

但是比较奇怪的是，ARP 请求报文以太网帧的目的地址居然不是广播，而是机器 A 的 MAC 地址？这和我们上面介绍的矛盾啊，为什么已经知道对方的 MAC 地址还要发送 ARP 报文去查询呢？

注意到，第三个报文距离上一个的时间间隔是 5s 左右，真正的 ICMP 报文（ping 应用传输的报文）已经在这个时间间隙中发送，也就是说机器 B 已经通过 A 发送的 ARP 报文把 ARP 保存到自己的缓存中了。第三个奇怪的 ARP 报文是为了**验证缓存的有效性**！

ARP 缓存都会有有效期，在 Linux 实现中，它会验证 ARP 缓存的有效性，并更新缓存记录的状态。因为已经知道对方的 ARP 记录，所以就没有必要再通过广播机制造成额外的网络资源浪费，这个 ARP 请求可以理解为： **请问 172.16.13.16，你的 MAC 地址还是 50:7b:9d:ca:08:f0吗？**。如果收到应答，说明该缓存记录有效；如果一直没有收到应答，则需要把缓存记录设置为失效或者删除，并在需要通信的时候使用正常的 ARP 请求获取对方的 MAC 地址。

**4、Gratuitous ARP（免费ARP）**

​	除了标准的 ARP 之外，还有一种特殊的 ARP 报文，称为 Gratuitous ARP（免费 ARP）。这个报文也是广播报文，它的特殊性在于，**它的报文中发送端 IP 地址和接收端 IP 地址都被设置为发送该报文的主机 IP**。为什么要有这样一个特殊的报文呢？因为它有用，比如：

- **检测 IP 冲突。**如果免费 ARP 请求接收到应答，说明当前网络上有另外一个和发送机器有相同 IP 的主机
- **可以用来更新网络中其他机器对于当前机器的 ARP 缓存。**如果机器重新配置了 IP 地址，那么免费 ARP 报文能够把新的 IP-MAC 匹配关系广播到网络中，接收到报文的机器更新自己的 ARP 缓存记录，这样就不会有因为 ARP 缓存失效导致的网络问题

### 五、ARP缺陷

ARP 协议很简单，通过缓存机制和 Gratuitous ARP 能够提供便利和高效的地址解析功能。尽管如此，和所有的网络协议一样，它并不是完美的，根据上面的解析，我们知道能发现它的两个不足之处：

1. ARP 报文**没有任何认证**，**假设所有的机器都可靠而且诚信**，所以 ARP 报文（尤其是应答）可以**伪造**。（窃听报文，或者报文转发）-> ARP spoofing
2. ARP 报文没有状态，机器可以在没有收到请求的时候直接发送应答。虽然特性能够有效地来更新 ARP 记录，也可能被恶意利用

ARP 报文另外一个让人迷惑的地方在于它在网络协议栈的位置：它既不属于二层（数据链路层），因为它不能把用户数据发送到目的机器，而且它其实是包在以太网帧里面；但它也不是三层（网络层），因为它没有在网络中寻路的功能。**它是介于二层和三层之间，更像是润滑剂的功能，帮助二层和三层正常工作。**

这是网络协议栈非常重要的一个特性，**网络协议是非常实用性的**。每个协议的产生为为了解决某个现实的问题，因为历史局限和现实设计问题，它可能并不完美，但是不妨碍它为我们提供服务。